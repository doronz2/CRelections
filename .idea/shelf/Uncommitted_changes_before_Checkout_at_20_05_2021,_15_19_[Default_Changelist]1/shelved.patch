Index: src/citivas/zkproofs.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>use elgamal::{ElGamal,rfc7919_groups::SupportedGroups,ElGamalPP,\n              ElGamalKeyPair,ElGamalError,ElGamalCiphertext,\n              ElGamalPrivateKey,ElGamalPublicKey,ExponentElGamal};\nuse curv::BigInt;\n\nuse curv::arithmetic::traits::Modulo;\nuse curv::arithmetic::traits::Samplable;\nuse curv::cryptographic_primitives::hashing::hash_sha256;\nuse curv::cryptographic_primitives::hashing::traits::Hash;\nuse std::convert::TryInto;\nuse vice_city::ProofError;\nuse serde::{Deserialize, Serialize};\nuse crate::citivas::voter::Voter;\nuse crate::citivas::entity::Entity;\nuse crate::citivas::supervisor::SystemParameters;\n\nuse std::ops::Neg;\n\n\n#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]\npub struct ReencProofInput{\n    pub(crate) c_list: Vec<ElGamalCiphertext>,//list of candidate for encryption\n    pub(crate) c : ElGamalCiphertext,\n }\n\n#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]\npub struct ReencProof{\n    d: Vec<BigInt>,\n    r: Vec<BigInt>\n}\n\n#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]\npub struct DLogProof {\n    pub random_point_1: BigInt,\n    pub response: BigInt,\n}\n\n#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]\npub struct Witness {\n    pub alpha_1: BigInt,\n    pub alpha_2: BigInt,\n}\n\n#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]\npub struct Statement {\n    pub h: BigInt,\n}\n\n#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]\npub struct VotePfPublicInput{\n    pub(crate) encrypted_credential: ElGamalCiphertext,\n    pub(crate) encrypted_choice: ElGamalCiphertext,\n    pub eid: BigInt //election identifier,\n}\n\n\n#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]\npub struct VotePfProof{\n    c:BigInt,\n    s1:BigInt,\n    s2:BigInt\n}\n\n\n#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]\npub struct VoteWitness{\n    pub(crate) alpha_1: BigInt,\n    pub(crate) alpha_2: BigInt\n}\n\n\n\n\n#[derive(Clone, PartialEq, Debug)]\npub struct DvrpPublicInput<'a> { //stands for designated-verifier reencryption proof\n    pub voter_public_key: &'a BigInt, // denoted hv in Civitas\n    pub prover_public_key: &'a BigInt, //for which e' is encrypted from e\n    pub e: &'a ElGamalCiphertext,\n    pub e_tag: &'a ElGamalCiphertext, //El-Gamal reencyption of e\n}\n\n\n#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]\npub struct DvrpProof { //stands for designated-verifier reencryption proof\nc: BigInt,\n    w: BigInt,\n    r: BigInt,\n    u: BigInt,\n}\n\n\n\n\npub trait ProveDLog {\n    fn prove(witness: &Witness, pp: &ElGamalPP) -> DLogProof;\n    fn verify(&self, statement: &Statement, pp: &ElGamalPP) -> Result<(), ProofError>;\n}\n\nimpl VoteWitness{\n\n\n    pub fn generate_random_witness(pp: &ElGamalPP)-> Self{\n        Self{\n            alpha_1: BigInt::sample_below(&pp.q),\n            alpha_2: BigInt::sample_below(&pp.q)\n        }\n    }\n}\n//a technical function that computes (x/x')^c mod p\nfn div_and_pow(denom: &BigInt, nom: &BigInt, c: &BigInt, p: &BigInt) -> BigInt {\n    BigInt::mod_pow(&(nom * BigInt::mod_inv(&denom, &p)), &c, &p)\n}\n\nimpl VotePfPublicInput{\n    pub fn generate_random_input(pp: &ElGamalPP, witness: &VoteWitness) -> Self{\n        let  a1: BigInt = BigInt::mod_pow(&pp.g, &witness.alpha_1, &pp.p);\n        let  a2: BigInt = BigInt::mod_pow(&pp.g, &witness.alpha_2, &pp.p);\n        let  b1: BigInt = BigInt::sample_below(&pp.p);\n        let  b2: BigInt = BigInt::sample_below(&pp.p);\n        let e1 = ElGamalCiphertext{\n            c1: a1,\n            c2: b1,\n            pp: pp.clone()\n        };\n        let e2 = ElGamalCiphertext{\n            c1: a2,\n            c2: b2,\n            pp: pp.clone()\n        };\n        let  ctx: BigInt = BigInt::sample_below(&pp.p);\n        Self{\n            encrypted_credential: e1,\n            encrypted_choice: e2,\n            eid: ctx}\n    }\n}\n\n\n// The following function proves the there is some c_t (for a private t) in a list of ciphers c_1,...,c_l that is\n// an encryption of some cipher text c=(u,v)\n// The following function is an attempt to implement [1] with Fiat-Shamir heuristic\n// L is the number of candidate of encryption and t stands for index of the real encrypted message.\n// Eta is the value that encrypts the message (represented by r in Civitas)\n// [1]: Hirt, Sako: Efficient receipt-free voting based on homomorphic encryption.\n\nimpl ReencProofInput {\n    pub fn reenc_in_list_1_out_of_L_prove(&self, pp: &ElGamalPP, pk: &ElGamalPublicKey, chosen_ciphertext_index: usize, eta: BigInt, L: usize) -> ReencProof {\n        if self.c_list.len() != L {\n            panic!(\"Size of the list doesn't match the specified list length L\")\n        }\n        if *pp != pk.pp {\n            panic!(\"mismatch pp\");\n        }\n        if chosen_ciphertext_index >= L {\n            panic! {\"t must be smaller than the size of the list\"}\n        }\n        let mut list_d_i = Vec::with_capacity(L);\n        let mut list_r_i = Vec::with_capacity(L);\n        let mut list_a_i = Vec::with_capacity(L);\n        let mut list_b_i = Vec::with_capacity(L);\n\n        for _ in 0..L {\n            list_d_i.push(BigInt::sample_below(&pp.q));\n            list_r_i.push(BigInt::sample_below(&pp.q));\n        }\n        let mut u_i: &BigInt;\n        let mut v_i: &BigInt;\n        for i in 0..L {\n            u_i = &self.c_list[i].c1;\n            v_i = &self.c_list[i].c2;\n            list_a_i.push(BigInt::mod_floor(&(div_and_pow(&self.c.c1, u_i, &list_d_i[i], &pp.p) *\n                BigInt::mod_pow(&pp.g, &list_r_i[i], &pp.p)), &pp.p));\n            list_b_i.push(BigInt::mod_floor(&(div_and_pow(&self.c.c2, v_i, &list_d_i[i], &pp.p) *\n                BigInt::mod_pow(&pk.h, &list_r_i[i], &pp.p)), &pp.p));\n        }\n\n        let mut E = {\n            let mut e_vec = Vec::new();\n            e_vec.push(&self.c.c1);\n            e_vec.push(&self.c.c2);\n            for e in self.c_list.iter() {\n                e_vec.push(&e.c1);\n            }\n            for e in self.c_list.iter() {\n                e_vec.push(&e.c2);\n            }\n            e_vec\n        };\n\n        E.extend(list_a_i.iter());\n        E.extend(list_b_i.iter());\n        // println!(\"E:{:#?}\", E);\n\n        let c = BigInt::mod_floor(&hash_sha256::HSha256::create_hash(\n            &E)\n                                  , &pp.q);\n        let w = BigInt::mod_floor(&(&eta * &list_d_i[chosen_ciphertext_index]\n            + &list_r_i[chosen_ciphertext_index]), &pp.q);\n        let sum: BigInt = list_d_i.iter().fold(BigInt::zero(), |a, b| a + b).mod_floor(&pp.q);\n        let tmp = (sum - &list_d_i[chosen_ciphertext_index]).mod_floor(&pp.q);\n        list_d_i[chosen_ciphertext_index] = BigInt::mod_floor(&(c - tmp)\n                                                              , &pp.q);\n        list_r_i[chosen_ciphertext_index] =\n            BigInt::mod_floor(&(&w - &eta * &list_d_i[chosen_ciphertext_index]), &pp.q);\n        ReencProof { d: list_d_i.try_into().unwrap(), r: list_r_i.try_into().unwrap() }\n    }\n\n    pub fn reenc_1_out_of_L_verifier(&self, pp: &ElGamalPP, pk: &ElGamalPublicKey, proof: &ReencProof, L: usize) -> bool {\n        let mut list_a_i = Vec::with_capacity(L);\n        let mut list_b_i = Vec::with_capacity(L);\n\n        let mut u_i: &BigInt;\n        let mut v_i: &BigInt;\n        for i in 0..L {\n            u_i = &self.c_list[i].c1;\n            v_i = &self.c_list[i].c2;\n            list_a_i.push(BigInt::mod_floor(&(div_and_pow(&self.c.c1, &u_i, &proof.d[i], &pp.p) *\n                BigInt::mod_pow(&pp.g, &proof.r[i], &pp.p)), &pp.p));\n            list_b_i.push(BigInt::mod_floor(&(div_and_pow(&self.c.c2, &v_i, &proof.d[i], &pp.p) *\n                BigInt::mod_pow(&pk.h, &proof.r[i], &pp.p)), &pp.p));\n        }\n\n        let mut E = {\n            let mut e_vec = Vec::new();\n            e_vec.push(&self.c.c1);\n            e_vec.push(&self.c.c2);\n            for e in self.c_list.iter() {\n                e_vec.push(&e.c1);\n            }\n            for e in self.c_list.iter() {\n                e_vec.push(&e.c2);\n            }\n            e_vec\n        };\n\n        E.extend(list_a_i.iter());\n        E.extend(list_b_i.iter());\n        //    println!(\"E:{:#?}\", E);\n\n        let c = hash_sha256::HSha256::create_hash(&E).mod_floor(&pp.q);\n        let sum: BigInt = proof.d.iter().fold(BigInt::zero(), |a, b| a + b);\n        let D = sum.mod_floor(&pp.q);\n        return c == D\n    }\n\n    // The following function proves that c=(u,v) is an encryption of some c_t (for a private t) in a list of ciphers c_1,...,c_l (See PROTOCOL: ReencPf in Civitas)\n    pub fn reenc_out_of_list_1_out_of_L_prove(&self, pp: &ElGamalPP, pk: &ElGamalPublicKey, chosen_ciphertext_index: usize, r: BigInt, L: usize) -> ReencProof {\n        if self.c_list.len() != L {\n            panic!(\"Size of the list doesn't match the specified list length L\")\n        }\n        if *pp != pk.pp {\n            panic!(\"mismatch pp\");\n        }\n        if chosen_ciphertext_index >= L {\n            panic! {\"t must be smaller than the size of the list\"}\n        }\n        let mut list_d_i = Vec::with_capacity(L);\n        let mut list_r_i = Vec::with_capacity(L);\n        let mut list_a_i = Vec::with_capacity(L);\n        let mut list_b_i = Vec::with_capacity(L);\n\n        for _ in 0..L {\n            list_d_i.push(BigInt::sample_below(&pp.q));\n            list_r_i.push(BigInt::sample_below(&pp.q));\n        }\n        let mut u_i: &BigInt;\n        let mut v_i: &BigInt;\n        for i in 0..L {\n            u_i = &self.c_list[i].c1;\n            v_i = &self.c_list[i].c2;\n            list_a_i.push(BigInt::mod_floor(&(div_and_pow(&self.c.c1, u_i, &list_d_i[i], &pp.p) *\n                BigInt::mod_pow(&pp.g, &list_r_i[i], &pp.p)), &pp.p));\n            list_b_i.push(BigInt::mod_floor(&(div_and_pow(&self.c.c2, v_i, &list_d_i[i], &pp.p) *\n                BigInt::mod_pow(&pk.h, &list_r_i[i], &pp.p)), &pp.p));\n        }\n\n        let mut E = {\n            let mut e_vec = Vec::new();\n            e_vec.push(&self.c.c1);\n            e_vec.push(&self.c.c2);\n            for e in self.c_list.iter() {\n                e_vec.push(&e.c1);\n            }\n            for e in self.c_list.iter() {\n                e_vec.push(&e.c2);\n            }\n            e_vec\n        };\n\n        E.extend(list_a_i.iter());\n        E.extend(list_b_i.iter());\n        // println!(\"E:{:#?}\", E);\n\n        let c = BigInt::mod_floor(&hash_sha256::HSha256::create_hash(\n            &E)\n                                  , &pp.q);\n        //a^t = g^(-r*d_t +r_t)\n        //w = -r * d_t + r_t ==> a^t = g^w\n        // d_t_new =c - (sum(d_i) - d_t)\n        // r_t_new = w + r * d_t_new\n        let w = BigInt::mod_floor(&(&r.clone().neg() * &list_d_i[chosen_ciphertext_index]\n            + &list_r_i[chosen_ciphertext_index]), &pp.q);\n        let sum: BigInt = list_d_i.iter().fold(BigInt::zero(), |a, b| a + b).mod_floor(&pp.q);\n        let tmp = (sum - &list_d_i[chosen_ciphertext_index]).mod_floor(&pp.q);\n        let d_t_new = BigInt::mod_floor(&(c - tmp)\n                                        , &pp.q);\n        let r_t_new = (w + &r * &d_t_new).mod_floor(&pp.q);\n        list_d_i[chosen_ciphertext_index] = d_t_new;\n         list_r_i[chosen_ciphertext_index] = r_t_new;\n        ReencProof { d: list_d_i.try_into().unwrap(), r: list_r_i.try_into().unwrap() }\n    }\n\n}\n\n    impl<'a> DvrpPublicInput<'a> {\n        pub fn create_input(voter_public_key: &'a BigInt, prover_public_key: &'a BigInt, e: &'a ElGamalCiphertext, e_tag: &'a ElGamalCiphertext) -> Self {\n            Self { voter_public_key, prover_public_key, e, e_tag }\n        }\n    }\n\n    impl VotePfPublicInput {\n        pub fn votepf_prover(&self, witness: VoteWitness,  params: &SystemParameters) -> VotePfProof {\n            let r1 = BigInt::sample_below(&params.pp.q);\n            let r2 = BigInt::sample_below(&params.pp.q);\n            let mut E = vec![&params.pp.g, &self.encrypted_credential.c1, &self.encrypted_credential.c2, &self.encrypted_choice.c1, &self.encrypted_choice.c2, &self.eid];\n            let pre_hash_1 = BigInt::mod_pow(&params.pp.g, &r1, &params.pp.p);\n            let pre_hash_2 = BigInt::mod_pow(&params.pp.g, &r2, &params.pp.p);\n            E.push(&pre_hash_1);\n            E.push(&pre_hash_2);\n//        println!(\"E = {:#?}\", E);\n            let c = hash_sha256::HSha256::create_hash(&E).mod_floor(&params.pp.q);\n            let s1 = (r1 - &c * witness.alpha_1).mod_floor(&params.pp.q);\n            let s2 = (r2 - &c * witness.alpha_2).mod_floor(&params.pp.q);\n            VotePfProof { c, s1, s2 }\n        }\n    }\n    impl VotePfProof {\n        pub fn votepf_verifier(&self, input: &VotePfPublicInput, params: &SystemParameters) -> bool {\n            let mut E = vec![&params.pp.g, &input.encrypted_credential.c1, &input.encrypted_credential.c2, &input.encrypted_choice.c1, &input.encrypted_choice.c2, &input.eid];\n            let pre_hash_1 = (BigInt::mod_pow(&params.pp.g, &self.s1, &params.pp.p) *\n                BigInt::mod_pow(&input.encrypted_credential.c1, &self.c, &params.pp.p)).mod_floor(&params.pp.p);\n            let pre_hash_2 = (BigInt::mod_pow(&params.pp.g, &self.s2, &params.pp.p) *\n                BigInt::mod_pow(&input.encrypted_choice.c1, &self.c, &params.pp.p)).mod_floor(&params.pp.p);\n            E.push(&pre_hash_1);\n            E.push(&pre_hash_2);\n            //   println!(\"E = {:#?}\", E);\n            let c = hash_sha256::HSha256::create_hash(&E).mod_floor(&params.pp.q);\n            self.c == c\n        }\n    }\n#[allow(dead_code)]\n    pub fn DVRP_prover<E: Entity>(entity: &E, dvrp_input: &DvrpPublicInput, eta: BigInt) -> DvrpProof {\n        //let d = BigInt::from(3);\n        let w = BigInt::from(2);\n        //let r = BigInt::from(5);\n        let d = BigInt::sample_below(&entity.get_q());\n        //let w = BigInt::sample_below(&entity.get_q());\n        let r = BigInt::sample_below(&entity.get_q());\n        let a = BigInt::mod_pow(&entity.get_generator(), &d, &entity.get_p());\n        let b = BigInt::mod_pow(&dvrp_input.prover_public_key, &d, &entity.get_p());\n        let s = BigInt::mod_mul(&BigInt::mod_pow(&entity.get_generator(), &w, &entity.get_p()),\n                                &BigInt::mod_pow(&dvrp_input.voter_public_key, &r, &entity.get_p()),\n                                &entity.get_p());\n        let c = BigInt::mod_floor(&hash_sha256::HSha256::create_hash(\n            &[&dvrp_input.e.c1, &dvrp_input.e.c2, &dvrp_input.e_tag.c1, &dvrp_input.e_tag.c2, &a, &b, &s]\n        ), &entity.get_q());\n\n        let u = (&d + &eta * (&c + &w)).mod_floor(&entity.get_q());\n        DvrpProof { c, w, r, u }\n    }\n\n\n    pub fn DVRP_verifier<E: Entity>(entity: &E, dvrp_input: &DvrpPublicInput, dvrp_proof: &DvrpProof) -> bool {\n        //a′ = g^u/(x′/x)^(c+w) mod p\n        let x = dvrp_input.e.c1.clone();\n        let y = dvrp_input.e.c2.clone();\n        let x_tag = dvrp_input.e_tag.c1.clone();\n        let y_tag = dvrp_input.e_tag.c2.clone();\n        let h = dvrp_input.prover_public_key;\n        let a_tag: BigInt = (BigInt::mod_pow(&entity.get_generator(), &dvrp_proof.u, &entity.get_p()) *\n            BigInt::mod_inv(&div_and_pow(&x, &x_tag, &(&dvrp_proof.c + &dvrp_proof.w), &entity.get_p())\n                            , &entity.get_p())).mod_floor(&entity.get_p());\n        let _nom = BigInt::mod_pow(&entity.get_generator(), &dvrp_proof.u, &entity.get_p());\n        let _denom = div_and_pow(&x, &x_tag, &(&dvrp_proof.c + &dvrp_proof.w), &entity.get_p());\n        let b_tag: BigInt = (BigInt::mod_pow(&h, &dvrp_proof.u, &entity.get_p()) *\n            BigInt::mod_inv(&div_and_pow(&y, &y_tag, &(&dvrp_proof.c + &dvrp_proof.w), &entity.get_p())\n                            , &entity.get_p())).mod_floor(&entity.get_p());\n        let s_tag = BigInt::mod_mul(&BigInt::mod_pow(&entity.get_generator(), &dvrp_proof.w, &entity.get_p()),\n                                    &BigInt::mod_pow(&dvrp_input.voter_public_key, &dvrp_proof.r, &entity.get_p()),\n                                    &entity.get_p());\n\n        let c_tag = BigInt::mod_floor(&hash_sha256::HSha256::create_hash(\n            &[&x, &y, &x_tag, &y_tag, &a_tag, &b_tag, &s_tag]\n        ), &entity.get_q());\n        // println!(\"dvrp verifier {:#?}\", [&x, &y,&x_tag, &y_tag, &a_tag, &b_tag, &s_tag]);\n\n        c_tag == dvrp_proof.c\n    }\n\n    pub fn fakeDVRP_prover(voter: &Voter, dvrp_input: &DvrpPublicInput) -> DvrpProof {\n        let x = &dvrp_input.e.c1;\n        let y = &dvrp_input.e.c2;\n        let x_tag = &dvrp_input.e_tag.c1;\n        let y_tag = &dvrp_input.e_tag.c2;\n        let alpha = BigInt::sample_below(&voter.get_q());\n        let beta = BigInt::sample_below(&voter.get_q());\n        let u_tilde = BigInt::sample_below(&voter.get_q());\n        let a_tilde: BigInt = (BigInt::mod_pow(&voter.get_generator(), &u_tilde, &voter.get_p()) *\n            BigInt::mod_inv(&div_and_pow(&x, &x_tag, &alpha, &voter.get_p())\n                            , &voter.get_p())).mod_floor(&voter.get_p());\n        let b_tilde: BigInt = (BigInt::mod_pow(&dvrp_input.prover_public_key, &u_tilde, &voter.get_p()) *\n            BigInt::mod_inv(&div_and_pow(&y, &y_tag, &alpha, &voter.get_p())\n                            , &voter.get_p())).mod_floor(&voter.get_p());\n        let s_tilde = BigInt::mod_pow(&voter.get_generator(), &beta, &voter.get_p());\n        let c_tilde = BigInt::mod_floor(&hash_sha256::HSha256::create_hash(\n            &[&x, &y, &x_tag, &y_tag, &a_tilde, &b_tilde, &s_tilde]\n        ), &voter.get_q());\n        // println!(\"dvrp fake prover {:#?}\", [&x, &y,&x_tag, &y_tag,  &a_tilde, &b_tilde, &s_tilde]);\n        let w_tilde = (&alpha - &c_tilde).mod_floor(&voter.get_q());\n        let r_tilde = (&(&(&beta - &w_tilde) * BigInt::mod_inv(&voter.designation_key_pair.sk.x, &voter.get_q())))\n            .mod_floor(&voter.get_q());\n        DvrpProof {\n            c: c_tilde,\n            w: w_tilde,\n            r: r_tilde,\n            u: u_tilde\n        }\n    }\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/citivas/zkproofs.rs b/src/citivas/zkproofs.rs
--- a/src/citivas/zkproofs.rs	
+++ b/src/citivas/zkproofs.rs	
@@ -327,7 +327,7 @@
             let pre_hash_2 = BigInt::mod_pow(&params.pp.g, &r2, &params.pp.p);
             E.push(&pre_hash_1);
             E.push(&pre_hash_2);
-//        println!("E = {:#?}", E);
+// println!("E = {:#?}", E);
             let c = hash_sha256::HSha256::create_hash(&E).mod_floor(&params.pp.q);
             let s1 = (r1 - &c * witness.alpha_1).mod_floor(&params.pp.q);
             let s2 = (r2 - &c * witness.alpha_2).mod_floor(&params.pp.q);
